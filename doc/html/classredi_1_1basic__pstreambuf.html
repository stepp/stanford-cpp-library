<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StanfordCPPLib: redi::basic_pstreambuf&lt; CharT, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StanfordCPPLib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceredi.html">redi</a></li><li class="navelem"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classredi_1_1basic__pstreambuf-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">redi::basic_pstreambuf&lt; CharT, Traits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class template for stream buffer.  
 <a href="classredi_1_1basic__pstreambuf.html#details">More...</a></p>

<p><code>#include "<a class="el" href="pstream_8h_source.html">pstream.h</a>"</code></p>
<div class="dynheader">
Inheritance diagram for redi::basic_pstreambuf&lt; CharT, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classredi_1_1basic__pstreambuf.png" usemap="#redi::basic_5Fpstreambuf_3C_20CharT_2C_20Traits_20_3E_map" alt=""/>
  <map id="redi::basic_5Fpstreambuf_3C_20CharT_2C_20Traits_20_3E_map" name="redi::basic_5Fpstreambuf_3C_20CharT_2C_20Traits_20_3E_map">
<area href="structredi_1_1pstreams.html" title="Common base class providing constants and typenames. " alt="redi::pstreams" shape="rect" coords="248,0,486,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a258ffd4e02fed4feb893ffccde0c7204"><td class="memItemLeft" align="right" valign="top"><a id="a258ffd4e02fed4feb893ffccde0c7204"></a>
typedef CharT&#160;</td><td class="memItemRight" valign="bottom"><b>char_type</b></td></tr>
<tr class="separator:a258ffd4e02fed4feb893ffccde0c7204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6889e5a67fc1c802ff355f9c53dd7f58"><td class="memItemLeft" align="right" valign="top"><a id="a6889e5a67fc1c802ff355f9c53dd7f58"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><b>traits_type</b></td></tr>
<tr class="separator:a6889e5a67fc1c802ff355f9c53dd7f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7468fdfa386d544276fd440dbd0d77b6"><td class="memItemLeft" align="right" valign="top"><a id="a7468fdfa386d544276fd440dbd0d77b6"></a>
typedef traits_type::int_type&#160;</td><td class="memItemRight" valign="bottom"><b>int_type</b></td></tr>
<tr class="separator:a7468fdfa386d544276fd440dbd0d77b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accba880c0c8c12b53677d9b64d86621b"><td class="memItemLeft" align="right" valign="top"><a id="accba880c0c8c12b53677d9b64d86621b"></a>
typedef traits_type::off_type&#160;</td><td class="memItemRight" valign="bottom"><b>off_type</b></td></tr>
<tr class="separator:accba880c0c8c12b53677d9b64d86621b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b655544c17c59ebb4af84e911400da0"><td class="memItemLeft" align="right" valign="top"><a id="a1b655544c17c59ebb4af84e911400da0"></a>
typedef traits_type::pos_type&#160;</td><td class="memItemRight" valign="bottom"><b>pos_type</b></td></tr>
<tr class="separator:a1b655544c17c59ebb4af84e911400da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa33e67df3b5330b2d29f8ceca3d9a15"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">fd_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#aaa33e67df3b5330b2d29f8ceca3d9a15">fd_t</a></td></tr>
<tr class="separator:aaa33e67df3b5330b2d29f8ceca3d9a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structredi_1_1pstreams"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structredi_1_1pstreams')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structredi_1_1pstreams.html">redi::pstreams</a></td></tr>
<tr class="memitem:a1eae4aad88812af03a0fbb3ec13c50b7 inherit pub_types_structredi_1_1pstreams"><td class="memItemLeft" align="right" valign="top"><a id="a1eae4aad88812af03a0fbb3ec13c50b7"></a>
typedef std::ios_base::openmode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a></td></tr>
<tr class="memdesc:a1eae4aad88812af03a0fbb3ec13c50b7 inherit pub_types_structredi_1_1pstreams"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to specify how to connect to the process. <br /></td></tr>
<tr class="separator:a1eae4aad88812af03a0fbb3ec13c50b7 inherit pub_types_structredi_1_1pstreams"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af902b894b095c1875e96c10129489467 inherit pub_types_structredi_1_1pstreams"><td class="memItemLeft" align="right" valign="top"><a id="af902b894b095c1875e96c10129489467"></a>
typedef std::vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structredi_1_1pstreams.html#af902b894b095c1875e96c10129489467">argv_type</a></td></tr>
<tr class="memdesc:af902b894b095c1875e96c10129489467 inherit pub_types_structredi_1_1pstreams"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to hold the arguments for a command. <br /></td></tr>
<tr class="separator:af902b894b095c1875e96c10129489467 inherit pub_types_structredi_1_1pstreams"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0b7eaed16eb6c22a56012958d85b1d inherit pub_types_structredi_1_1pstreams"><td class="memItemLeft" align="right" valign="top"><a id="add0b7eaed16eb6c22a56012958d85b1d"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">fd_type</a></td></tr>
<tr class="memdesc:add0b7eaed16eb6c22a56012958d85b1d inherit pub_types_structredi_1_1pstreams"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for file descriptors. <br /></td></tr>
<tr class="separator:add0b7eaed16eb6c22a56012958d85b1d inherit pub_types_structredi_1_1pstreams"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae66decd83183a35608ada0a56cb8d97b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#ae66decd83183a35608ada0a56cb8d97b">basic_pstreambuf</a>()</td></tr>
<tr class="memdesc:ae66decd83183a35608ada0a56cb8d97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ae66decd83183a35608ada0a56cb8d97b">More...</a><br /></td></tr>
<tr class="separator:ae66decd83183a35608ada0a56cb8d97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff497d97764d0917274d3a3f775bbe0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#aff497d97764d0917274d3a3f775bbe0c">basic_pstreambuf</a>(string cmd, <a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a> mode)</td></tr>
<tr class="memdesc:aff497d97764d0917274d3a3f775bbe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that initialises the buffer with <em>cmd</em>.  <a href="#aff497d97764d0917274d3a3f775bbe0c">More...</a><br /></td></tr>
<tr class="separator:aff497d97764d0917274d3a3f775bbe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5196b0eeb2747e77558f237c9ea185"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a7d5196b0eeb2747e77558f237c9ea185">basic_pstreambuf</a>(string file, const <a class="el" href="structredi_1_1pstreams.html#af902b894b095c1875e96c10129489467">argv_type</a> &amp;argv, <a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a> mode)</td></tr>
<tr class="memdesc:a7d5196b0eeb2747e77558f237c9ea185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that initialises the buffer with <em>file</em> and <em>argv</em>.  <a href="#a7d5196b0eeb2747e77558f237c9ea185">More...</a><br /></td></tr>
<tr class="separator:a7d5196b0eeb2747e77558f237c9ea185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d7cdeacc2f34a06d5b6be09498c1a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a53d7cdeacc2f34a06d5b6be09498c1a1">~basic_pstreambuf</a>()</td></tr>
<tr class="memdesc:a53d7cdeacc2f34a06d5b6be09498c1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a53d7cdeacc2f34a06d5b6be09498c1a1">More...</a><br /></td></tr>
<tr class="separator:a53d7cdeacc2f34a06d5b6be09498c1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91e4317d9e95b4551513a00e3d82996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#ac91e4317d9e95b4551513a00e3d82996">open</a>(string cmd, <a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a> mode)</td></tr>
<tr class="memdesc:ac91e4317d9e95b4551513a00e3d82996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the stream buffer with <em>cmd</em>.  <a href="#ac91e4317d9e95b4551513a00e3d82996">More...</a><br /></td></tr>
<tr class="separator:ac91e4317d9e95b4551513a00e3d82996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd6e94de1a2fa0e9e4505934b246aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a2dd6e94de1a2fa0e9e4505934b246aec">open</a>(string file, const <a class="el" href="structredi_1_1pstreams.html#af902b894b095c1875e96c10129489467">argv_type</a> &amp;argv, <a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a> mode)</td></tr>
<tr class="memdesc:a2dd6e94de1a2fa0e9e4505934b246aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the stream buffer with <em>file</em> and <em>argv</em>.  <a href="#a2dd6e94de1a2fa0e9e4505934b246aec">More...</a><br /></td></tr>
<tr class="separator:a2dd6e94de1a2fa0e9e4505934b246aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725edcfa569034899d63312fa8d98791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a725edcfa569034899d63312fa8d98791">close</a>()</td></tr>
<tr class="memdesc:a725edcfa569034899d63312fa8d98791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the stream buffer and wait for the process to exit.  <a href="#a725edcfa569034899d63312fa8d98791">More...</a><br /></td></tr>
<tr class="separator:a725edcfa569034899d63312fa8d98791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6648f57f7aa212f986365101a66d5350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a6648f57f7aa212f986365101a66d5350">kill</a>(int signal=SIGTERM)</td></tr>
<tr class="memdesc:a6648f57f7aa212f986365101a66d5350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to the process.  <a href="#a6648f57f7aa212f986365101a66d5350">More...</a><br /></td></tr>
<tr class="separator:a6648f57f7aa212f986365101a66d5350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151b701c789459216e92bd7b76d59872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a151b701c789459216e92bd7b76d59872">killpg</a>(int signal=SIGTERM)</td></tr>
<tr class="memdesc:a151b701c789459216e92bd7b76d59872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to the process' process group.  <a href="#a151b701c789459216e92bd7b76d59872">More...</a><br /></td></tr>
<tr class="separator:a151b701c789459216e92bd7b76d59872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6937e84719c4eaf08f2a2e514ff98e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a6937e84719c4eaf08f2a2e514ff98e93">peof</a>()</td></tr>
<tr class="memdesc:a6937e84719c4eaf08f2a2e514ff98e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the pipe connected to the process' stdin.  <a href="#a6937e84719c4eaf08f2a2e514ff98e93">More...</a><br /></td></tr>
<tr class="separator:a6937e84719c4eaf08f2a2e514ff98e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a92bd02d774f26d6165f99bb5661bce"><td class="memItemLeft" align="right" valign="top"><a id="a9a92bd02d774f26d6165f99bb5661bce"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>pid</b> () const</td></tr>
<tr class="separator:a9a92bd02d774f26d6165f99bb5661bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831c1a0ec6deb5ef2cbcab5cf510969"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#ac831c1a0ec6deb5ef2cbcab5cf510969">read_err</a>(bool readerr=true)</td></tr>
<tr class="memdesc:ac831c1a0ec6deb5ef2cbcab5cf510969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change active input source.  <a href="#ac831c1a0ec6deb5ef2cbcab5cf510969">More...</a><br /></td></tr>
<tr class="separator:ac831c1a0ec6deb5ef2cbcab5cf510969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28fab6dc978b25c92740400512a61bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#af28fab6dc978b25c92740400512a61bc">is_open</a>() const</td></tr>
<tr class="memdesc:af28fab6dc978b25c92740400512a61bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether the stream buffer has been initialised.  <a href="#af28fab6dc978b25c92740400512a61bc">More...</a><br /></td></tr>
<tr class="separator:af28fab6dc978b25c92740400512a61bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed1ec24bfa867c99b6bf8a35a94d063"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a9ed1ec24bfa867c99b6bf8a35a94d063">exited</a>()</td></tr>
<tr class="memdesc:a9ed1ec24bfa867c99b6bf8a35a94d063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether the process has exited.  <a href="#a9ed1ec24bfa867c99b6bf8a35a94d063">More...</a><br /></td></tr>
<tr class="separator:a9ed1ec24bfa867c99b6bf8a35a94d063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad82c80f955784adfd34a1608a15193"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a2ad82c80f955784adfd34a1608a15193">status</a>() const</td></tr>
<tr class="memdesc:a2ad82c80f955784adfd34a1608a15193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exit status of the process.  <a href="#a2ad82c80f955784adfd34a1608a15193">More...</a><br /></td></tr>
<tr class="separator:a2ad82c80f955784adfd34a1608a15193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e5bc3b59a7cb3f72fd81ebde783c13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a87e5bc3b59a7cb3f72fd81ebde783c13">error</a>() const</td></tr>
<tr class="memdesc:a87e5bc3b59a7cb3f72fd81ebde783c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the error number (errno) for the most recent failed operation.  <a href="#a87e5bc3b59a7cb3f72fd81ebde783c13">More...</a><br /></td></tr>
<tr class="separator:a87e5bc3b59a7cb3f72fd81ebde783c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a8a3f6a830b6035ed755188e32ffffadc"><td class="memItemLeft" align="right" valign="top"><a id="a8a3f6a830b6035ed755188e32ffffadc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a8a3f6a830b6035ed755188e32ffffadc">buf_read_src</a> { <b>rsrc_out</b> = 0, 
<b>rsrc_err</b> = 1
 }</td></tr>
<tr class="memdesc:a8a3f6a830b6035ed755188e32ffffadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type to indicate whether stdout or stderr is to be read. <br /></td></tr>
<tr class="separator:a8a3f6a830b6035ed755188e32ffffadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_structredi_1_1pstreams"><td colspan="2" onclick="javascript:toggleInherit('pro_types_structredi_1_1pstreams')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="structredi_1_1pstreams.html">redi::pstreams</a></td></tr>
<tr class="memitem:a9bff4a02e7fed3943fd197d4cc3a887a inherit pro_types_structredi_1_1pstreams"><td class="memItemLeft" align="right" valign="top"><a id="a9bff4a02e7fed3943fd197d4cc3a887a"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>bufsz</b> = 32
 }</td></tr>
<tr class="separator:a9bff4a02e7fed3943fd197d4cc3a887a inherit pro_types_structredi_1_1pstreams"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92512e6281229147c3991acc020ddaa inherit pro_types_structredi_1_1pstreams"><td class="memItemLeft" align="right" valign="top"><a id="af92512e6281229147c3991acc020ddaa"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>pbsz</b> = 2
 }</td></tr>
<tr class="separator:af92512e6281229147c3991acc020ddaa inherit pro_types_structredi_1_1pstreams"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a563d5dbb28ee2713933e648bd839be2d"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a563d5dbb28ee2713933e648bd839be2d">overflow</a>(int_type c)</td></tr>
<tr class="memdesc:a563d5dbb28ee2713933e648bd839be2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer characters to the pipe when character buffer overflows.  <a href="#a563d5dbb28ee2713933e648bd839be2d">More...</a><br /></td></tr>
<tr class="separator:a563d5dbb28ee2713933e648bd839be2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c2677fc95c3f3debf8ec169684703b"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#af7c2677fc95c3f3debf8ec169684703b">underflow</a>()</td></tr>
<tr class="memdesc:af7c2677fc95c3f3debf8ec169684703b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer characters from the pipe when the character buffer is empty.  <a href="#af7c2677fc95c3f3debf8ec169684703b">More...</a><br /></td></tr>
<tr class="separator:af7c2677fc95c3f3debf8ec169684703b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbff787187463c3ff1e76a3abb75adc"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#accbff787187463c3ff1e76a3abb75adc">pbackfail</a>(int_type c=traits_type::eof())</td></tr>
<tr class="memdesc:accbff787187463c3ff1e76a3abb75adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a character available to be returned by the next extraction.  <a href="#accbff787187463c3ff1e76a3abb75adc">More...</a><br /></td></tr>
<tr class="separator:accbff787187463c3ff1e76a3abb75adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d46d50b5f0959dc40d0e254f2edff8"><td class="memItemLeft" align="right" valign="top"><a id="a65d46d50b5f0959dc40d0e254f2edff8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a65d46d50b5f0959dc40d0e254f2edff8">sync</a> ()</td></tr>
<tr class="memdesc:a65d46d50b5f0959dc40d0e254f2edff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write any buffered characters to the stream. <br /></td></tr>
<tr class="separator:a65d46d50b5f0959dc40d0e254f2edff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329b61903a31fa3113b583f0be9fbf8d"><td class="memItemLeft" align="right" valign="top">std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a329b61903a31fa3113b583f0be9fbf8d">xsputn</a>(const char_type *s, std::streamsize n)</td></tr>
<tr class="memdesc:a329b61903a31fa3113b583f0be9fbf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert multiple characters into the pipe.  <a href="#a329b61903a31fa3113b583f0be9fbf8d">More...</a><br /></td></tr>
<tr class="separator:a329b61903a31fa3113b583f0be9fbf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f8ea6b033a4623ce854363a64b908a"><td class="memItemLeft" align="right" valign="top">std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a48f8ea6b033a4623ce854363a64b908a">write</a>(const char_type *s, std::streamsize n)</td></tr>
<tr class="memdesc:a48f8ea6b033a4623ce854363a64b908a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a sequence of characters into the pipe.  <a href="#a48f8ea6b033a4623ce854363a64b908a">More...</a><br /></td></tr>
<tr class="separator:a48f8ea6b033a4623ce854363a64b908a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac98c1a7954de8c0c2833f3da30788b"><td class="memItemLeft" align="right" valign="top">std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a3ac98c1a7954de8c0c2833f3da30788b">read</a>(char_type *s, std::streamsize n)</td></tr>
<tr class="memdesc:a3ac98c1a7954de8c0c2833f3da30788b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a sequence of characters from the pipe.  <a href="#a3ac98c1a7954de8c0c2833f3da30788b">More...</a><br /></td></tr>
<tr class="separator:a3ac98c1a7954de8c0c2833f3da30788b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd03e965dfb0488d5329373350519a9"><td class="memItemLeft" align="right" valign="top"><a id="abdd03e965dfb0488d5329373350519a9"></a>
std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#abdd03e965dfb0488d5329373350519a9">showmanyc</a> ()</td></tr>
<tr class="memdesc:abdd03e965dfb0488d5329373350519a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report how many characters can be read from active input without blocking. <br /></td></tr>
<tr class="separator:abdd03e965dfb0488d5329373350519a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a3b8c71fa2019eefff0ef6e8a92d5b"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a70a3b8c71fa2019eefff0ef6e8a92d5b">fork</a>(<a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a> mode)</td></tr>
<tr class="memdesc:a70a3b8c71fa2019eefff0ef6e8a92d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise pipes and fork process.  <a href="#a70a3b8c71fa2019eefff0ef6e8a92d5b">More...</a><br /></td></tr>
<tr class="separator:a70a3b8c71fa2019eefff0ef6e8a92d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa976526cfb7ea56e29afbee8ead68e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1">wait</a>(bool nohang=false)</td></tr>
<tr class="memdesc:afa976526cfb7ea56e29afbee8ead68e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the child process to exit.  <a href="#afa976526cfb7ea56e29afbee8ead68e1">More...</a><br /></td></tr>
<tr class="separator:afa976526cfb7ea56e29afbee8ead68e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982f0dcfc35efedf63c0906611060ba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">fd_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a982f0dcfc35efedf63c0906611060ba7">wpipe</a>()</td></tr>
<tr class="memdesc:a982f0dcfc35efedf63c0906611060ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the file descriptor for the output pipe.  <a href="#a982f0dcfc35efedf63c0906611060ba7">More...</a><br /></td></tr>
<tr class="separator:a982f0dcfc35efedf63c0906611060ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdb0b3a802ffb924c66cfffed2563dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">fd_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#accdb0b3a802ffb924c66cfffed2563dd">rpipe</a>()</td></tr>
<tr class="memdesc:accdb0b3a802ffb924c66cfffed2563dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the file descriptor for the active input pipe.  <a href="#accdb0b3a802ffb924c66cfffed2563dd">More...</a><br /></td></tr>
<tr class="separator:accdb0b3a802ffb924c66cfffed2563dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9241b9835a5978a0b9b183c8f2ed81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">fd_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a0b9241b9835a5978a0b9b183c8f2ed81">rpipe</a>(<a class="el" href="classredi_1_1basic__pstreambuf.html#a8a3f6a830b6035ed755188e32ffffadc">buf_read_src</a> which)</td></tr>
<tr class="memdesc:a0b9241b9835a5978a0b9b183c8f2ed81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the file descriptor for the specified input pipe.  <a href="#a0b9241b9835a5978a0b9b183c8f2ed81">More...</a><br /></td></tr>
<tr class="separator:a0b9241b9835a5978a0b9b183c8f2ed81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2761951761f2ef2b947d79d1609e90df"><td class="memItemLeft" align="right" valign="top"><a id="a2761951761f2ef2b947d79d1609e90df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>create_buffers</b> (<a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a> mode)</td></tr>
<tr class="separator:a2761951761f2ef2b947d79d1609e90df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e338a431ee8c94cbf8d4399c875c258"><td class="memItemLeft" align="right" valign="top"><a id="a6e338a431ee8c94cbf8d4399c875c258"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy_buffers</b> (<a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a> mode)</td></tr>
<tr class="separator:a6e338a431ee8c94cbf8d4399c875c258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d2bb07c6d563cbf9886d69fa42523e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#aa9d2bb07c6d563cbf9886d69fa42523e">empty_buffer</a>()</td></tr>
<tr class="memdesc:aa9d2bb07c6d563cbf9886d69fa42523e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes buffered characters to the process' stdin pipe.  <a href="#aa9d2bb07c6d563cbf9886d69fa42523e">More...</a><br /></td></tr>
<tr class="separator:aa9d2bb07c6d563cbf9886d69fa42523e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84fcdc04e6d81fc1118b21c4ba6e5b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#ac84fcdc04e6d81fc1118b21c4ba6e5b2">fill_buffer</a>(bool non_blocking=false)</td></tr>
<tr class="separator:ac84fcdc04e6d81fc1118b21c4ba6e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8e9fd297080561faf0f74c538cf12d"><td class="memItemLeft" align="right" valign="top">char_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#abd8e9fd297080561faf0f74c538cf12d">rbuffer</a>()</td></tr>
<tr class="memdesc:abd8e9fd297080561faf0f74c538cf12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the active input buffer.  <a href="#abd8e9fd297080561faf0f74c538cf12d">More...</a><br /></td></tr>
<tr class="separator:abd8e9fd297080561faf0f74c538cf12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66875e53c746460d7357e1427de9dd0e"><td class="memItemLeft" align="right" valign="top"><a id="a66875e53c746460d7357e1427de9dd0e"></a>
<a class="el" href="classredi_1_1basic__pstreambuf.html#a8a3f6a830b6035ed755188e32ffffadc">buf_read_src</a>&#160;</td><td class="memItemRight" valign="bottom"><b>switch_read_buffer</b> (<a class="el" href="classredi_1_1basic__pstreambuf.html#a8a3f6a830b6035ed755188e32ffffadc">buf_read_src</a>)</td></tr>
<tr class="separator:a66875e53c746460d7357e1427de9dd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(<a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a1f07c96f98013de48578043f0caa0e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a1f07c96f98013de48578043f0caa0e82">close_fd</a>(<a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">pstreams::fd_type</a> &amp;fd)</td></tr>
<tr class="memdesc:a1f07c96f98013de48578043f0caa0e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to close a file descriptor.  <a href="#a1f07c96f98013de48578043f0caa0e82">More...</a><br /></td></tr>
<tr class="separator:a1f07c96f98013de48578043f0caa0e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7a0d3e1009028f3f6af0fe96a9743e"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a8b7a0d3e1009028f3f6af0fe96a9743e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classredi_1_1basic__pstreambuf.html#a8b7a0d3e1009028f3f6af0fe96a9743e">close_fd_array</a>(<a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">pstreams::fd_type</a>(&amp;fds)[N])</td></tr>
<tr class="memdesc:a8b7a0d3e1009028f3f6af0fe96a9743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to close an array of file descriptors.  <a href="#a8b7a0d3e1009028f3f6af0fe96a9743e">More...</a><br /></td></tr>
<tr class="separator:a8b7a0d3e1009028f3f6af0fe96a9743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_structredi_1_1pstreams"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_structredi_1_1pstreams')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="structredi_1_1pstreams.html">redi::pstreams</a></td></tr>
<tr class="memitem:a7a976ce992db857f86a0cc3352e42d3a inherit pub_static_attribs_structredi_1_1pstreams"><td class="memItemLeft" align="right" valign="top"><a id="a7a976ce992db857f86a0cc3352e42d3a"></a>
static const <a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structredi_1_1pstreams.html#a7a976ce992db857f86a0cc3352e42d3a">pstdin</a> = std::ios_base::out</td></tr>
<tr class="memdesc:a7a976ce992db857f86a0cc3352e42d3a inherit pub_static_attribs_structredi_1_1pstreams"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to stdin. <br /></td></tr>
<tr class="separator:a7a976ce992db857f86a0cc3352e42d3a inherit pub_static_attribs_structredi_1_1pstreams"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c6d53a98de4566478b1c40c101a42b inherit pub_static_attribs_structredi_1_1pstreams"><td class="memItemLeft" align="right" valign="top"><a id="ad3c6d53a98de4566478b1c40c101a42b"></a>
static const <a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structredi_1_1pstreams.html#ad3c6d53a98de4566478b1c40c101a42b">pstdout</a> = std::ios_base::in</td></tr>
<tr class="memdesc:ad3c6d53a98de4566478b1c40c101a42b inherit pub_static_attribs_structredi_1_1pstreams"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from stdout. <br /></td></tr>
<tr class="separator:ad3c6d53a98de4566478b1c40c101a42b inherit pub_static_attribs_structredi_1_1pstreams"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423b8ad263d442ba726b5f8e5812b7ef inherit pub_static_attribs_structredi_1_1pstreams"><td class="memItemLeft" align="right" valign="top"><a id="a423b8ad263d442ba726b5f8e5812b7ef"></a>
static const <a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structredi_1_1pstreams.html#a423b8ad263d442ba726b5f8e5812b7ef">pstderr</a> = std::ios_base::app</td></tr>
<tr class="memdesc:a423b8ad263d442ba726b5f8e5812b7ef inherit pub_static_attribs_structredi_1_1pstreams"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from stderr. <br /></td></tr>
<tr class="separator:a423b8ad263d442ba726b5f8e5812b7ef inherit pub_static_attribs_structredi_1_1pstreams"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cbc4d00cb5fb1e2f38403781367d12 inherit pub_static_attribs_structredi_1_1pstreams"><td class="memItemLeft" align="right" valign="top"><a id="a83cbc4d00cb5fb1e2f38403781367d12"></a>
static const <a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structredi_1_1pstreams.html#a83cbc4d00cb5fb1e2f38403781367d12">newpg</a> = std::ios_base::trunc</td></tr>
<tr class="memdesc:a83cbc4d00cb5fb1e2f38403781367d12 inherit pub_static_attribs_structredi_1_1pstreams"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new process group for the child process. <br /></td></tr>
<tr class="separator:a83cbc4d00cb5fb1e2f38403781367d12 inherit pub_static_attribs_structredi_1_1pstreams"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt;<br />
class redi::basic_pstreambuf&lt; CharT, Traits &gt;</h3>

<p>Class template for stream buffer. </p>
<p>Provides underlying streambuf functionality for the PStreams classes. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaa33e67df3b5330b2d29f8ceca3d9a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa33e67df3b5330b2d29f8ceca3d9a15">&#9670;&nbsp;</a></span>fd_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">fd_type</a> <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; CharT, Traits &gt;::<a class="el" href="classredi_1_1basic__pstreambuf.html#aaa33e67df3b5330b2d29f8ceca3d9a15">fd_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>use <a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d" title="Type used for file descriptors. ">pstreams::fd_type</a> instead.</dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae66decd83183a35608ada0a56cb8d97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66decd83183a35608ada0a56cb8d97b">&#9670;&nbsp;</a></span>basic_pstreambuf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::<a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an uninitialised stream buffer.</p>

</div>
</div>
<a id="aff497d97764d0917274d3a3f775bbe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff497d97764d0917274d3a3f775bbe0c">&#9670;&nbsp;</a></span>basic_pstreambuf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::<a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a> </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that initialises the buffer with <em>cmd</em>. </p>
<p>Initialises the stream buffer by calling <a class="el" href="classredi_1_1basic__pstreambuf.html#ac91e4317d9e95b4551513a00e3d82996" title="Initialise the stream buffer with cmd. ">open()</a> with the supplied arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>a string containing a shell command. </td></tr>
    <tr><td class="paramname">mode</td><td>the I/O mode to use when opening the pipe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classredi_1_1basic__pstreambuf.html#ac91e4317d9e95b4551513a00e3d82996" title="Initialise the stream buffer with cmd. ">open()</a> </dd></dl>

</div>
</div>
<a id="a7d5196b0eeb2747e77558f237c9ea185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5196b0eeb2747e77558f237c9ea185">&#9670;&nbsp;</a></span>basic_pstreambuf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::<a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a> </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structredi_1_1pstreams.html#af902b894b095c1875e96c10129489467">argv_type</a> &amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that initialises the buffer with <em>file</em> and <em>argv</em>. </p>
<p>Initialises the stream buffer by calling <a class="el" href="classredi_1_1basic__pstreambuf.html#ac91e4317d9e95b4551513a00e3d82996" title="Initialise the stream buffer with cmd. ">open()</a> with the supplied arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a string containing the name of a program to execute. </td></tr>
    <tr><td class="paramname">argv</td><td>a vector of argument strings passsed to the new program. </td></tr>
    <tr><td class="paramname">mode</td><td>the I/O mode to use when opening the pipe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classredi_1_1basic__pstreambuf.html#ac91e4317d9e95b4551513a00e3d82996" title="Initialise the stream buffer with cmd. ">open()</a> </dd></dl>

</div>
</div>
<a id="a53d7cdeacc2f34a06d5b6be09498c1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d7cdeacc2f34a06d5b6be09498c1a1">&#9670;&nbsp;</a></span>~basic_pstreambuf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::~<a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Closes the stream by calling <a class="el" href="classredi_1_1basic__pstreambuf.html#a725edcfa569034899d63312fa8d98791" title="Close the stream buffer and wait for the process to exit. ">close()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classredi_1_1basic__pstreambuf.html#a725edcfa569034899d63312fa8d98791" title="Close the stream buffer and wait for the process to exit. ">close()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a725edcfa569034899d63312fa8d98791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725edcfa569034899d63312fa8d98791">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a>&lt; C, T &gt; * <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the stream buffer and wait for the process to exit. </p>
<p>Closes all pipes and calls <a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">wait()</a> to wait for the process to finish.</p>
<p>If an error occurs the error code will be set to one of the possible errors for <code>waitpid()</code>. See your system's documentation for these errors.</p>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> on successful close or <code>nullptr</code> if there is no process to close or if an error occurs. </dd></dl>

</div>
</div>
<a id="aa9d2bb07c6d563cbf9886d69fa42523e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d2bb07c6d563cbf9886d69fa42523e">&#9670;&nbsp;</a></span>empty_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::empty_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes buffered characters to the process' stdin pipe. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer was emptied, false otherwise. </dd></dl>

</div>
</div>
<a id="a87e5bc3b59a7cb3f72fd81ebde783c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e5bc3b59a7cb3f72fd81ebde783c13">&#9670;&nbsp;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the error number (errno) for the most recent failed operation. </p>
<dl class="section return"><dt>Returns</dt><dd>The error code of the most recently failed operation, or zero. </dd></dl>

</div>
</div>
<a id="a9ed1ec24bfa867c99b6bf8a35a94d063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed1ec24bfa867c99b6bf8a35a94d063">&#9670;&nbsp;</a></span>exited()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::exited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report whether the process has exited. </p>
<p>This function can call <a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">pstreambuf::wait()</a> and so may change the object's state if the child process has already exited.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the associated process has exited, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">basic_pstreambuf&lt;C,T&gt;::wait()</a> </dd></dl>

</div>
</div>
<a id="ac84fcdc04e6d81fc1118b21c4ba6e5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84fcdc04e6d81fc1118b21c4ba6e5b2">&#9670;&nbsp;</a></span>fill_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::fill_buffer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>non_blocking</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the buffer was filled, false otherwise. </dd></dl>

</div>
</div>
<a id="a70a3b8c71fa2019eefff0ef6e8a92d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a3b8c71fa2019eefff0ef6e8a92d5b">&#9670;&nbsp;</a></span>fork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pid_t <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::fork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise pipes and fork process. </p>
<p>Creates pipes as specified by <em>mode</em> and calls <code><a class="el" href="classredi_1_1basic__pstreambuf.html#a70a3b8c71fa2019eefff0ef6e8a92d5b" title="Initialise pipes and fork process. ">fork()</a></code> to create a new process.</p>
<p>If the fork is successful the parent process stores the child's PID and the opened pipes and the child process replaces its standard streams with the opened pipes.</p>
<p>If an error occurs the error code will be set to one of the possible errors for <code>pipe()</code> or <code><a class="el" href="classredi_1_1basic__pstreambuf.html#a70a3b8c71fa2019eefff0ef6e8a92d5b" title="Initialise pipes and fork process. ">fork()</a></code>. See your system's documentation for these error codes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>an OR of pmodes specifying which of the child's standard streams to connect to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success the PID of the child is returned in the parent's context and zero is returned in the child's context. On error -1 is returned and the error code is set appropriately. </dd></dl>

</div>
</div>
<a id="af28fab6dc978b25c92740400512a61bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28fab6dc978b25c92740400512a61bc">&#9670;&nbsp;</a></span>is_open()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report whether the stream buffer has been initialised. </p>
<p>Unlike <a class="el" href="classredi_1_1basic__pstreambuf.html#a9ed1ec24bfa867c99b6bf8a35a94d063" title="Report whether the process has exited. ">pstreambuf::exited()</a>, this function will not call <a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">wait()</a> and so will not change the object's state.</p>
<p>This means that once a child process is executed successfully this function will continue to return true even after the process exits (until <a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">wait()</a> is called.)</p>
<dl class="section return"><dt>Returns</dt><dd>true if a previous call to <a class="el" href="classredi_1_1basic__pstreambuf.html#ac91e4317d9e95b4551513a00e3d82996" title="Initialise the stream buffer with cmd. ">open()</a> succeeded and <a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">wait()</a> has not been called and determined that the process has exited, false otherwise. </dd></dl>

</div>
</div>
<a id="a6648f57f7aa212f986365101a66d5350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6648f57f7aa212f986365101a66d5350">&#9670;&nbsp;</a></span>kill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a>&lt; C, T &gt; * <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::kill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em> = <code>SIGTERM</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a signal to the process. </p>
<p>Sends the specified signal to the process.</p>
<p>A signal can be used to terminate a child process that would not exit otherwise.</p>
<p>If an error occurs the error code will be set to one of the possible errors for <code><a class="el" href="classredi_1_1basic__pstreambuf.html#a6648f57f7aa212f986365101a66d5350" title="Send a signal to the process. ">kill()</a></code>. See your system's documentation for these errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>A signal to send to the child process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> or <code>nullptr</code> if <code><a class="el" href="classredi_1_1basic__pstreambuf.html#a6648f57f7aa212f986365101a66d5350" title="Send a signal to the process. ">kill()</a></code> fails. </dd></dl>

</div>
</div>
<a id="a151b701c789459216e92bd7b76d59872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151b701c789459216e92bd7b76d59872">&#9670;&nbsp;</a></span>killpg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a>&lt; C, T &gt; * <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::killpg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em> = <code>SIGTERM</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a signal to the process' process group. </p>
<p>Sends the specified signal to the process group of the child process.</p>
<p>A signal can be used to terminate a child process that would not exit otherwise, or to kill the process and its own children.</p>
<p>If an error occurs the error code will be set to one of the possible errors for <code>getpgid()</code> or <code><a class="el" href="classredi_1_1basic__pstreambuf.html#a6648f57f7aa212f986365101a66d5350" title="Send a signal to the process. ">kill()</a></code>. See your system's documentation for these errors. If the child is in the current process group then nullptr will be returned and the error code set to EPERM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>A signal to send to the child process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> on success or <code>nullptr</code> on failure. </dd></dl>

</div>
</div>
<a id="ac91e4317d9e95b4551513a00e3d82996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91e4317d9e95b4551513a00e3d82996">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a>&lt; C, T &gt; * <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::open </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the stream buffer with <em>cmd</em>. </p>
<p>Starts a new process by passing <em>command</em> to the shell (/bin/sh) and opens pipes to the process with the specified <em>mode</em>.</p>
<p>If <em>mode</em> contains <code>pstdout</code> the initial read source will be the child process' stdout, otherwise if <em>mode</em> contains <code>pstderr</code> the initial read source will be the child's stderr.</p>
<p>Will duplicate the actions of the shell in searching for an executable file if the specified file name does not contain a slash (/) character.</p>
<dl class="section warning"><dt>Warning</dt><dd>There is no way to tell whether the shell command succeeded, this function will always succeed unless resource limits (such as memory usage, or number of processes or open files) are exceeded. This means <a class="el" href="classredi_1_1basic__pstreambuf.html#af28fab6dc978b25c92740400512a61bc" title="Report whether the stream buffer has been initialised. ">is_open()</a> will return true even if <em>command</em> cannot be executed. Use <a class="el" href="classredi_1_1basic__pstreambuf.html#a2dd6e94de1a2fa0e9e4505934b246aec" title="Initialise the stream buffer with file and argv. ">pstreambuf::open(const string&amp;, const argv_type&amp;, pmode)</a> if you need to know whether the command failed to execute.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>a string containing a shell command. </td></tr>
    <tr><td class="paramname">mode</td><td>a bitwise OR of one or more of <code>out</code>, <code>in</code>, <code>err</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if the shell could not be started or the pipes could not be opened, <code>this</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><b>execl</b>(3) </dd></dl>

</div>
</div>
<a id="a2dd6e94de1a2fa0e9e4505934b246aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd6e94de1a2fa0e9e4505934b246aec">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a>&lt; C, T &gt; * <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::open </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structredi_1_1pstreams.html#af902b894b095c1875e96c10129489467">argv_type</a> &amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structredi_1_1pstreams.html#a1eae4aad88812af03a0fbb3ec13c50b7">pmode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the stream buffer with <em>file</em> and <em>argv</em>. </p>
<p>Starts a new process by executing <em>file</em> with the arguments in <em>argv</em> and opens pipes to the process with the specified <em>mode</em>.</p>
<p>By convention <code>argv</code>[0] should be the file name of the file being executed.</p>
<p>If <em>mode</em> contains <code>pstdout</code> the initial read source will be the child process' stdout, otherwise if <em>mode</em> contains <code>pstderr</code> the initial read source will be the child's stderr.</p>
<p>Will duplicate the actions of the shell in searching for an executable file if the specified file name does not contain a slash (/) character.</p>
<p>Iff <em>file</em> is successfully executed then <a class="el" href="classredi_1_1basic__pstreambuf.html#af28fab6dc978b25c92740400512a61bc" title="Report whether the stream buffer has been initialised. ">is_open()</a> will return true. Otherwise, <a class="el" href="classredi_1_1basic__pstreambuf.html#a87e5bc3b59a7cb3f72fd81ebde783c13" title="Return the error number (errno) for the most recent failed operation. ">pstreambuf::error()</a> can be used to obtain the value of <code>errno</code> that was set by <b>execvp</b>(3) in the child process.</p>
<p>The exit status of the new process will be returned by <a class="el" href="classredi_1_1basic__pstreambuf.html#a2ad82c80f955784adfd34a1608a15193" title="Return the exit status of the process. ">pstreambuf::status()</a> after <a class="el" href="classredi_1_1basic__pstreambuf.html#a9ed1ec24bfa867c99b6bf8a35a94d063" title="Report whether the process has exited. ">pstreambuf::exited()</a> returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a string containing the pathname of a program to execute. </td></tr>
    <tr><td class="paramname">argv</td><td>a vector of argument strings passed to the new program. </td></tr>
    <tr><td class="paramname">mode</td><td>a bitwise OR of one or more of <code>out</code>, <code>in</code> and <code>err</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if a pipe could not be opened or if the program could not be executed, <code>this</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><b>execvp</b>(3) </dd></dl>

</div>
</div>
<a id="a563d5dbb28ee2713933e648bd839be2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563d5dbb28ee2713933e648bd839be2d">&#9670;&nbsp;</a></span>overflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a>&lt; C, T &gt;::int_type <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::overflow </td>
          <td>(</td>
          <td class="paramtype">int_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer characters to the pipe when character buffer overflows. </p>
<p>Called when the internal character buffer is not present or is full, to transfer the buffer contents to the pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a character to be written to the pipe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>traits_type::eof()</code> if an error occurs, otherwise if <em>c</em> is not equal to <code>traits_type::eof()</code> it will be buffered and a value other than <code>traits_type::eof()</code> returned to indicate success. </dd></dl>

</div>
</div>
<a id="accbff787187463c3ff1e76a3abb75adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbff787187463c3ff1e76a3abb75adc">&#9670;&nbsp;</a></span>pbackfail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a>&lt; C, T &gt;::int_type <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::pbackfail </td>
          <td>(</td>
          <td class="paramtype">int_type&#160;</td>
          <td class="paramname"><em>c</em> = <code>traits_type::eof()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a character available to be returned by the next extraction. </p>
<p>Attempts to make <em>c</em> available as the next character to be read by <code>sgetc()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a character to make available for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>c</em> if the character can be made available, <code>traits_type::eof()</code> otherwise. </dd></dl>

</div>
</div>
<a id="a6937e84719c4eaf08f2a2e514ff98e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6937e84719c4eaf08f2a2e514ff98e93">&#9670;&nbsp;</a></span>peof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::peof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the pipe connected to the process' stdin. </p>
<p>Closes the output pipe, causing the child process to receive the end-of-file indicator on subsequent reads from its <code>stdin</code> stream. </p>

</div>
</div>
<a id="abd8e9fd297080561faf0f74c538cf12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8e9fd297080561faf0f74c538cf12d">&#9670;&nbsp;</a></span>rbuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a>&lt; C, T &gt;::char_type * <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::rbuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the active input buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the active input buffer area. </dd></dl>

</div>
</div>
<a id="a3ac98c1a7954de8c0c2833f3da30788b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac98c1a7954de8c0c2833f3da30788b">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamsize <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">char_type *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::streamsize&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a sequence of characters from the pipe. </p>
<p>Reads up to <em>n</em> characters from the pipe to the buffer <em>s</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>character buffer. </td></tr>
    <tr><td class="paramname">n</td><td>buffer length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters read. </dd></dl>

</div>
</div>
<a id="ac831c1a0ec6deb5ef2cbcab5cf510969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac831c1a0ec6deb5ef2cbcab5cf510969">&#9670;&nbsp;</a></span>read_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::read_err </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readerr</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change active input source. </p>
<p>Toggle the stream used for reading.</p>
<p>If <em>readerr</em> is <code>true</code> then the process' <code>stderr</code> output will be used for subsequent extractions, if <em>readerr</em> is false the the process' stdout will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readerr</td><td><code>true</code> to read <code>stderr</code>, <code>false</code> to read <code>stdout</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the requested stream is open and will be used for subsequent extractions, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="accdb0b3a802ffb924c66cfffed2563dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdb0b3a802ffb924c66cfffed2563dd">&#9670;&nbsp;</a></span>rpipe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">pstreams::fd_type</a> &amp; <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::rpipe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the file descriptor for the active input pipe. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the active input file descriptor </dd></dl>

</div>
</div>
<a id="a0b9241b9835a5978a0b9b183c8f2ed81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9241b9835a5978a0b9b183c8f2ed81">&#9670;&nbsp;</a></span>rpipe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">pstreams::fd_type</a> &amp; <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::rpipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classredi_1_1basic__pstreambuf.html#a8a3f6a830b6035ed755188e32ffffadc">buf_read_src</a>&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the file descriptor for the specified input pipe. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the specified input file descriptor </dd></dl>

</div>
</div>
<a id="a2ad82c80f955784adfd34a1608a15193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad82c80f955784adfd34a1608a15193">&#9670;&nbsp;</a></span>status()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the exit status of the process. </p>
<dl class="section return"><dt>Returns</dt><dd>The exit status of the child process, or -1 if <a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">wait()</a> has not yet been called to wait for the child to exit. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">basic_pstreambuf&lt;C,T&gt;::wait()</a> </dd></dl>

</div>
</div>
<a id="af7c2677fc95c3f3debf8ec169684703b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c2677fc95c3f3debf8ec169684703b">&#9670;&nbsp;</a></span>underflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classredi_1_1basic__pstreambuf.html">basic_pstreambuf</a>&lt; C, T &gt;::int_type <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::underflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer characters from the pipe when the character buffer is empty. </p>
<p>Called when the internal character buffer is is empty, to re-fill it from the pipe.</p>
<dl class="section return"><dt>Returns</dt><dd>The first available character in the buffer, or <code>traits_type::eof()</code> in case of failure. </dd></dl>

</div>
</div>
<a id="afa976526cfb7ea56e29afbee8ead68e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa976526cfb7ea56e29afbee8ead68e1">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nohang</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the child process to exit. </p>
<p>Suspends execution and waits for the associated process to exit, or until a signal is delivered whose action is to terminate the current process or to call a signal handling function.</p>
<p>If the process has already exited (i.e. it is a "zombie" process) then <a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">wait()</a> returns immediately. Waiting for the child process causes all its system resources to be freed.</p>
<p><a class="el" href="classredi_1_1basic__pstreambuf.html#a87e5bc3b59a7cb3f72fd81ebde783c13" title="Return the error number (errno) for the most recent failed operation. ">error()</a> will return EINTR if <a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">wait()</a> is interrupted by a signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nohang</td><td>true to return immediately if the process has not exited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the process has exited and <a class="el" href="classredi_1_1basic__pstreambuf.html#afa976526cfb7ea56e29afbee8ead68e1" title="Wait for the child process to exit. ">wait()</a> has not yet been called. 0 if <em>nohang</em> is true and the process has not exited yet. -1 if no process has been started or if an error occurs, in which case the error can be found using <a class="el" href="classredi_1_1basic__pstreambuf.html#a87e5bc3b59a7cb3f72fd81ebde783c13" title="Return the error number (errno) for the most recent failed operation. ">error()</a>. </dd></dl>

</div>
</div>
<a id="a982f0dcfc35efedf63c0906611060ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982f0dcfc35efedf63c0906611060ba7">&#9670;&nbsp;</a></span>wpipe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">pstreams::fd_type</a> &amp; <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::wpipe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the file descriptor for the output pipe. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the output file descriptor </dd></dl>

</div>
</div>
<a id="a48f8ea6b033a4623ce854363a64b908a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f8ea6b033a4623ce854363a64b908a">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamsize <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const char_type *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::streamsize&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a sequence of characters into the pipe. </p>
<p>Writes up to <em>n</em> characters to the pipe from the buffer <em>s</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>character buffer. </td></tr>
    <tr><td class="paramname">n</td><td>buffer length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters written. </dd></dl>

</div>
</div>
<a id="a329b61903a31fa3113b583f0be9fbf8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329b61903a31fa3113b583f0be9fbf8d">&#9670;&nbsp;</a></span>xsputn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamsize <a class="el" href="classredi_1_1basic__pstreambuf.html">redi::basic_pstreambuf</a>&lt; C, T &gt;::xsputn </td>
          <td>(</td>
          <td class="paramtype">const char_type *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::streamsize&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert multiple characters into the pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>character buffer. </td></tr>
    <tr><td class="paramname">n</td><td>buffer length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters written. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a1f07c96f98013de48578043f0caa0e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f07c96f98013de48578043f0caa0e82">&#9670;&nbsp;</a></span>close_fd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void close_fd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">pstreams::fd_type</a> &amp;&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to close a file descriptor. </p>
<p>Inspects <em>fd</em> and calls <b>close</b>(3) if it has a non-negative value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>a file descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b7a0d3e1009028f3f6af0fe96a9743e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7a0d3e1009028f3f6af0fe96a9743e">&#9670;&nbsp;</a></span>close_fd_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void close_fd_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structredi_1_1pstreams.html#add0b7eaed16eb6c22a56012958d85b1d">pstreams::fd_type</a>(&amp;)&#160;</td>
          <td class="paramname"><em>fds</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to close an array of file descriptors. </p>
<p>Calls <code><a class="el" href="classredi_1_1basic__pstreambuf.html#a1f07c96f98013de48578043f0caa0e82" title="Helper function to close a file descriptor. ">close_fd()</a></code> on each member of the array. The length of the array is determined automatically by template argument deduction to avoid errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fds</td><td>an array of file descriptors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/stepp/Dropbox/data/docs/stanford/StanfordCPPLib/StanfordCPPLib/system/<a class="el" href="pstream_8h_source.html">pstream.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
